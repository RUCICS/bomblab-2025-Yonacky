# bomblab 报告

姓名：安昊宇

学号：2024201650

| 总分 | phase_1 | phase_2 | phase_3 | phase_4 | phase_5 | phase_6 | secret_phase |
| --------- | ------------- | ------------- | ------------- | ----------------- |-----------|-----------|-----------|
| 3        | 2            | 1           | 0        | 0 |0  |0  |0  |


scoreboard截图：
![alt text](.\image.png)

## 解题报告
### phase1:
```c
"But when anger's bottled up inside, can I resist against unspoken words or try to hide?"
```
#### 汇编代码解读：
先开辟临时空间，然后lea加载0x1440+0x1d40=0x3180处的字符串指针放入rsi。
调用strings_not_equal，查看该函数发现传入两个字符串相等时返回0（存入eax），否则返回1.接下来test判断，如果相等就释放返回phase1，否则调用explode_bomb。

#### 拆弹分析：
只需要找到0x3180处的字符串输入就可以了。在IDA中按G输入0x3180就可以跳转到那里，复制叫做“aButWhenAngerSB”的字符串内容作为答案：
But when anger's bottled up inside, can I resist against unspoken words or try to hide?

#### 心得体会：
算是第一次阅读实际工程中的汇编代码，虽然这个例子比较简单，一开始拿到的时候还是不知所措，把一些虽然没看懂但不重要的地方拿去问了AI才舒服。
输入答案的时候炸了2次，因为看IDA里面没看懂字符串是什么样子的，直接复制粘贴了，实际上要去掉扩住字符串的单引号，还要把代表单引号的字符转换过来。

### phase2:
```c
565232 705223 630895 679982
```
#### 汇编代码解读：
在IDA中发现了一些神秘代码，查询后发现是IDA给这段函数的栈帧自动起的“局部变量占位名”，表示基于栈指针或基指针的偏移量。比如var_48 dword ptr -48h就表示在栈上0x48开始有4字节的局部变量。qword表示8字节，byte表示1个字节。
函数前面的部分，先保存了两个callee-reg，然后开辟了38字节空间。接下来是用rax从fs:28h处取了一个金丝雀值，然后保存到栈帧里，调用结束后再弹出比对。用eax异或自己是为了置零。
接下来是存储参数，rdx/rcx/r8/r9分别把4个参数存入栈空间，其中rdx就写在栈顶，其余依次偏移，我为它们命名，顺序如下：
rsp +4 +8 +12(0Ch) +16(10h)
rdx rcx r8  r9
n1  n2  n3  n4      m
从n1到n4是输入的参数，现在还不清楚m是什么。
rsi读取了一个格式字符串“%d %d %d %d %d %d”作为_sscanf的输入。然后调用_sscanf进行输入，返回值如果不是4个就爆炸。
观察了一下后续代码，有很多只重复两三次的循环，很可能是在做跟小矩阵有关的运算。
先看有一坨嵌套循环的部分。循环一共有三层，最外层循环有2次，中间的有2次，最里面的是3次。
先看最内层循环的核心运算，指针rax每次分别移动0/4/8字节读取matA_2中的数，并与matB_1中偏移0/8/16的数相乘。根据多维数组存储的行优先原则，到这里基本可以确定，数据类型为4字节大小的int，矩阵A为2×3，矩阵B为3×2，这是在做两个矩阵的矩阵乘法。矩阵乘法的答案存入从m开始的一个数组中，可以称为结果数组C。
再看后面的一个循环体，现在就很清晰了。这里把结果数组C的指针赋给rbp，然后遍历这个数组，与从rsp开始的四个数字（也就是一开始输入的四个参数n1到n4）依次比较，只要有一个不同就会爆炸。
全部通过后，检查金丝雀值是否改变，如果有，调用___stack_chk_fail，没有就释放返回。

#### 拆弹分析：
我们只需要知道矩阵乘法的结果就可以了。在IDA中点击数组名，去内存里找到A和B中的数字，计算矩阵乘法，得到：
C[[0x89ff0, 0xac2c7], [0x9a06f, 0xa602e]]，转化为十进制输入即可
答案：565232 705223 630895 679982

#### 心得体会
这个样例明显比前一个复杂很多，但是期中考试做过一道类似的题目，所以有一些印象。一开始从前往后看，一行一行翻译，一头雾水，浪费了很多时间。后来尝试从整体去看结构，分清主次，很快就弄明白了。一开始分析的时候不知道m那里放了什么，十分困惑，从全局来看也是豁然开朗，验算以后发现确实是一开始就分配好的数组空间。同时也熟练了IDA的使用方法，感觉IDA确实是一款比较伟大的工具，可惜考试考gdb。（不过我到这里暂时还没用到gdb）
这个炸了一次，因为第一次去读数字的时候只读了一行的，并不知道数字实际上是怎么分布的（所以用gdb读取就可以避免这种问题……后面都用gdb了）

### phase3:
```c
5 -454
```
#### 汇编代码解读：
函数开头建栈+保护，读入两个整数（记作x, y）作为输入。
接下来先检查y，如果不是负数直接爆炸，然后是x，如果不是0-7之间的整数就爆炸。接下来出现了非常多的跳转代码块，合理认为这就是一个switch语句。分析得到rdx指向跳转表基址1599，eax是索引idx，取基址+4*idx处的4字节int值。movsxd将这个4字节扩展到8字节，说明跳转表中存的是相对偏移，再加上rdx里的基址就成为了绝对地址，然后跳转到这个绝对地址。
我们观察各个case。159B是case0，最终走到15AA，无条件炸。同理，case1/2/3最终也汇入15AA，所以都不行。接下来看case4-1606，跟着它的路线走下来，到程序尾部之前eax最终为0。case5-160D走下来到尾部之前eax为-0x1C6.
由于尾部还有idx<=5的检查，所以case6和7也是必炸的，就不看了。
最后对输入参数进行检查，y必须等于eax。否则爆炸。满足后检查并返回。
#### 拆弹分析：
x就是那个最后能走通的case5，由于一开始输入是十进制格式，所以将case5的eax=-0x1C6转为十进制就是y。
答案为：5 -454
#### 心得体会：
phase3的代码一开始看起来是很复杂的一大坨，但是联想到跳转表以后就好做了。关键在于movsxd的那一步，可以联想到相对偏移转绝对地址的过程。看路线，应该只有一条能走到最后，发现好几条都会汇总到Loc_15AA炸掉，回溯排查发现是0-3，最后还排除了6和7，那就看4和5谁可以，发现4的y为0，不是负数，因此只能是case5的eax作为答案。

### phase4:
```c
31 CA
```
#### 汇编代码解读：
这里首先读入了一个整数和一个长度为2的字符串，如果没有接收到2个参数就爆炸。程序栈这样分配：
rsp +0Ch +10h   +14h   +18h   +20h
    int string buffer canary
首先调用了一个递归函数func4_1，阅读后发现是f(n)=2*f(n-1)+1=2^n-1，初始n=5，返回结果31，与输入的第一个整数比对，如果不一样就爆炸。
接着调用string_length检查string长度是否为2，不是就爆炸。接着调用func4_2，发现实际上就是汉诺塔问题。阅读后可以写出伪代码：
```
void func4_2(int n, int k, char a, char b, char c, char *out)
{
    if (n==1) {
        out[0] = a;
        out[1] = b;
        out[2] = '\0';
        return;
    }
    int mid=func4_1(n-1);  // 2^(n-1)-1
    if (k<=mid) {
        func4_2(n-1, k, a, c, b, out);
        return;
    }
    if (k==mid+1) {
        out[0] = a;
        out[1] = b;
        out[2] = '\0';
        return;
    }
    func4_2(n-1, k-(mid+1), c, b, a, out);
}
```
这个函数最后返回一个字符串，如果输入的字符串与它不相等就会爆炸。
最后检查canary并返回。
#### 拆弹分析：
第一个参数已经得到，就是31.第二个参数只需要在func4_2返回的下一行打个断点然后输出buffer看一下就可以了。得到结果为CA
答案：31 CA
#### 心得体会：
phase4的代码出现了两个递归函数，第一个还比较简单，第二个读得十分痛苦，后来发现在递归调用时调换了参数位置，本着“这个lab应该不会有很复杂的东西”的思想，意识到这就是移盘子的汉诺塔问题（加上在phase1查看字符串区时见到过monk move plates之类的字样），这下看懂了。但我其实还是不会汉诺塔问题，肯定不能自己手推，发现它只是检查结果，所以打断点得到func4_2的返回值就可以了

### phase5:
```c
-13 100
```
#### 汇编代码解读：
代码开头部分和前面几个都一样。读入两个十进制整数（记作x和y），存在rsp和rsp+4的位置。如果x>=0就会爆炸。接着取低4位和0xF做与运算，相当于x=x%15.
观察下面的循环，edx是计数器，ecx是总和，rsi指向int数组array_0.循环每次用取出的值作为下一轮的下标来查找，很像一个单链表的结构。直到索引等于15时停止，每次会把值累加到总和中。第一个索引是上面得到的x。
最后的检验是：循环次数edx等于13，总和ecx等于输入的y。
#### 拆弹分析：
我们需要找到合适的起始值，使得链表能在跳转13次后走到15，此时总和应该是唯一的。使用IDA找到array_0数组，读出里面的值：
下标:00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15
next:10 02 14 07 08 12 15 11 00 04 01 13 03 09 06 05
其实只需要从后往前走13次就行了：15 6 14 2 1 10 0 8 4 9 13 11 7 3，可知第一个索引是3.
接着，从3开始计算总和，过程略，得到100作为输入y。
第一个输入是对15取模得到的负数，所以任何满足这个条件的数字都可以，这里取最简单的答案-13作为输入x。
答案：-13 100
#### 心得体会：
这次的代码比前面短了许多，关键在于读循环明白单链表的结构，再到内存中找到单链表，模拟循环的过程计算出答案。

### phase6:
```c
6 2 3 4 5 1
```
#### 汇编代码解读：
read_six_numbers会把读入的6个int（记作a[i]）写入缓冲区var_98，这6个数字必须在1-6范围内，并且互不相同，否则爆炸。接着把每个输入变为7-a[i]。
接着，用变换后的a[i]去链表里取节点并存入指针数组p[6]，然后使用指针数组重连链表，最终得到的链表中的值必须从0到6降序排列，否则爆炸。
#### 拆弹分析：
我们要做的是给出一个重连方式，使得链表内的值降序排列。只需要去读取6个node的值就好了，读取时发现node6被编码在另一块地方了，但是不影响阅读。直接对它们降序重排，得到重连后的结点顺序为：1 5 4 3 2 6，再分别用7减它们得到原输入序列。
答案：6 2 3 4 5 1
#### 心得体会：
这道题与上一道题类似，也是对链表进行操作，需要注意的是重连的序号是每个输入的数被7减以后变换得来的。

### secret phase:
```c
33022
```
#### 汇编代码解读：
查看main函数，发现每个phase调用后都调用了一个phase_defused，这个函数没有在前面任何一个phase出现过，点进去查看，发现它读取输入中是否一共有6个空格再加上我的秘密词（"enigma"）。刚才phase6的输入正好有一些空格，直接在phase6阶段输入密码：6 2 3 4 5 1 enigma
即可进入secret phase。
找到secret phase，阅读代码发现其实就是读入一个长度在20以内的字符串，使得func7(s, 0, 0, 0)返回非零。
阅读func7，实际上是一个在地图上行走的过程。第一个参数是读入的指令序列，然后是x和y的坐标，最后是读指令的指针/走到第几步。观察分支的总体发现，走到(4, 7)时会直接返回1，那么就是找到一种移动到那里的指令序列。
代码中的走法，很像中国象棋的马，走一个“日”字，如果中间被卡住就不能走过去。
棋盘用row数组存储，每个row是一个链表结点，内容是一个大小为8的数组和一个next指针。
移动时用递归调用推进，如果到目标就返回1，越界或者被卡住就返回0，很显然，这类似一个dfs的算法。
#### 拆弹分析：
只要找到合法行走序列就行了，读取8个row数组：
row0: 0 0 1 0 0 1 0 0
row1: 0 0 0 1 0 0 0 1
row2: 1 0 1 0 0 1 0 0
row3: 1 0 0 0 0 0 0 0
row4: 0 1 0 0 1 0 1 0
row5: 1 0 0 1 1 0 0 0
row6: 0 0 0 0 0 1 0 1
row7: 0 1 0 0 0 0 0 0
在纸上画出了棋盘，自己进行了一些尝试。结合AI得到了最短路径。
答案：33022
#### 心得体会：
找到这个phase进入的方式很有意思，实际上IDA能很明显看出这两个函数的定义，为了找到是谁调用了它们，需要右键函数名并查看交叉引用。发现main函数调用了它，一切就豁然开朗了。有了前面几个phase的铺垫，阅读这个phase也不算很难，虽然func7很长，但是分块阅读并关注关键量的话，还是能读明白的（还有文件中多次出现的horse提示）。bomblab还是蛮好玩的。

## 参考的重要资料
《深入理解计算机系统》
IDA的使用参考了《IDA-Pro权威指南（第2版）》
也阅读了《C++反汇编与逆向分析技术揭秘（第2版）》
感谢ChatGPT5.2
